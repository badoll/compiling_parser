# 编译原理作业
### 环境
Apple clang version 11.0.0 (clang-1100.0.33.12)
### 语言
C++11
### 用法
```shell
make
bin/main testfile/file
```
# 词法分析
### 目的
分析文本中是否有非法词语。
### 实现
使用lexical_parser类逐行分析文本，每一行文本读取到string中，然后一个字符一个字符分析，合法则添加到words向量中，非法则报错，然后跳过分析下一个词语。  
### 种别码
|单词|种别码|
|:--:|:--:|
|main|1|
|if|2|
|while|3|
|+|4|
|-|5|
|*|6|
|/|7|
|=|8|
|<|9|
|<=|10|
|>|11|
|>=|12|
|==|13|
|!=|14|
|;|15|
|(|16|
|)|17|
|{|18|
|}|19|
|//|20|
|VARIABLE|21|
|DIGIT|22|

# 语法分析
### 目的
分析简单的赋值语句  
```c
main()
{
    x = 11 ; y = (x+1*y)+(1);
}
```  
### 文法
- <程序> ::= main()<语句块>  
- <语句块> ::= ‘{‘<语句串>’}’  
- <语句串> ::= <语句>;{<语句>;}  
- <语句> ::= <赋值语句>|<条件语句>|<循环语句>  
- <赋值语句> ::= VARIABLE=<表达式>  
- <条件语句> ::= if(条件)<语句块>  
- <循环语句> ::= while(条件)<语句块>  
- <条件> ::= <表达式><关系运算符><表达式>  
- <表达式> ::= <项>{+<项>|-<项>}  
- <项> ::= <因子>{*<因子>|/<因子>}  
- <因子> ::= VARIABLE|DIGIT|(<表达式>)  
- <关系运算符> ::= <|<=|>|>=|==|!=  

### 实现
递归下降的语法分析。用syntactic_parser类继承lexical_parser类，调用继承过来的scan函数来一个个读取词语，读取的同时进行词法分析，分析完没有错误就再进行语法分析，有词法错误就报错然后返回一个带非法标志的词语。
语法分析使用简单的错误恢复方法，若缺少赋值号，则循环取下一个词语直到遇到分号（语句结束符）或变量（语句开始符），若循环结束前没有赋值号，则报错缺少赋值号，然后开始分析下一条语句。若匹配到赋值号，则将前面出现的词语报错，然后开始分析赋值号后面的表达式。缺少分号的错误分析方法同赋值号。

# 语义分析
### 目的
对简单赋值语句生成四元式和三地址中间代码。
### 实现
若一个赋值语句语法分析没有错误，则在语法分析的递归中将一个表达式中的元素（包括操作数、运算符和暂时存放运算结果的一个中间元素）加入到四元组（tuple）中，最后再将表达式赋值号左边的变量和赋值号右边最终的中间元素（如果没有复杂运算则是一个变量或数字）放入四元组中。  
如果是条件判断语句，则再调用分析语句块的函数，分析出语句块中有几条中间代码，根据语句块中中间代码的数量推出条件判断跳转的中间代码，然后再将该跳转语句的中间代码插入中间代码元组中。

# 测试数据
- 样例1  
```c
main()
{
    if (a > b) {
        a = 2 + 3 * 4; x = (a + b)/c;
    }
    while (a > 0) {
        if (a > b) {
            a = 2 + 3 * 4; x = (a + b)/c;
        }
        x = 11 ; y = (x+1*y)+(1);
    }
}
```
```
Words: (1,main) (16,() (17,)) (18,{) (2,if) (16,() (21,a) (11,>) (21,b) (17,)) (18,{) (21,a) (8,=) (22,2) (4,+) (22,3) (6,*) (22,4) (15,;) (21,x) (8,=) (16,() (21,a) (4,+) (21,b) (17,)) (7,/) (21,c) (15,;) (19,}) (3,while) (16,() (21,a) (11,>) (22,0) (17,)) (18,{) (2,if) (16,() (21,a) (11,>) (21,b) (17,)) (18,{) (21,a) (8,=) (22,2) (4,+) (22,3) (6,*) (22,4) (15,;) (21,x) (8,=) (16,() (21,a) (4,+) (21,b) (17,)) (7,/) (21,c) (15,;) (19,}) (21,x) (8,=) (22,11) (15,;) (21,y) (8,=) (16,() (21,x) (4,+) (22,1) (6,*) (21,y) (17,)) (4,+) (16,() (22,1) (17,)) (15,;) (19,}) (19,}) 

success

Intermediate Code:
(1): if a > b goto (3)
(2): goto (9)
(3): T1 = 3 * 4
(4): T2 = 2 + T1
(5): a = T2
(6): T3 = a + b
(7): T4 = T3 / c
(8): x = T4
(9): if a > 0 goto (11)
(10): goto (25)
(11): if a > b goto (13)
(12): goto (19)
(13): T5 = 3 * 4
(14): T6 = 2 + T5
(15): a = T6
(16): T7 = a + b
(17): T8 = T7 / c
(18): x = T8
(19): x = 11
(20): T9 = 1 * y
(21): T10 = x + T9
(22): T11 = T10 + 1
(23): y = T11
(24): goto (9)
(25): halt
```

- 样例2  
```c
main()
{
	x  11 ; y = (x+1*y)+(1);
}
```
```
Words: (1,main) (16,() (17,)) (18,{) (21,x) (22,11) (15,;) (21,y) (8,=) (16,() (21,x) (4,+) (22,1) (6,*) (21,y) (17,)) (4,+) (16,() (22,1) (17,)) (15,;) (19,}) 

ERROR:
Line 3: lack of '='

Intermediate Code:
(1): T1 = 1 * y
(2): T2 = x + T1
(3): T3 = T2 + 1
(4): y = T3
(5): halt
```
- 样例3
```c
main()
{
	x = 11 ; y = (x+1*y)();
}
```
```
Words: (1,main) (16,() (17,)) (18,{) (21,x) (8,=) (22,11) (15,;) (21,y) (8,=) (16,() (21,x) (4,+) (22,1) (6,*) (21,y) (17,)) (16,() (17,)) (15,;) (19,}) 

ERROR:
Line 3: error symbol ()

Intermediate Code:
(1): x = 11
(2): T1 = 1 * y
(3): T2 = x + T1
(4): y = T2
(5): halt
```
- 样例4
```c
main()
{
	x = 11 ; y)) = (x+1*y)+(1);
}
```
```
Words: (1,begin) (10,x) (17,:=) (11,11) (27,;) (10,y) (17,:=) (29,)) (27,;) (6,end) 
ERROR:
Line 2: lack of factor
Line 2: error symbol )
```
- 样例5
```c
main()
{
    x = 11 ; y)) = (x+1*y)+(1);
}
```
```
Words: (1,main) (16,() (17,)) (18,{) (21,x) (8,=) (22,11) (15,;) (21,y) (17,)) (17,)) (8,=) (16,() (21,x) (4,+) (22,1) (6,*) (21,y) (17,)) (4,+) (16,() (22,1) (17,)) (15,;) (19,}) 

ERROR:
Line 3: error symbol ))

Intermediate Code:
(1): x = 11
(2): T1 = 1 * y
(3): T2 = x + T1
(4): T3 = T2 + 1
(5): y = T3
(6): halt
```
